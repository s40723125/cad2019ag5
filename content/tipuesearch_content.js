var tipuesearch = {"pages": [{'title': 'member', 'text': '成員: \n 40523113 \xa0 吳宜賢 \n 40623252 \xa0 李展齊 \n 40723101 \xa0 沈易萱 \n 40723103 \xa0 林晏瑩 \n 40723107 \xa0 王晨祐 \n 40723114 \xa0 杜永瀚 \n 40723119 \xa0 林哲緯 \n 40723122 \xa0 施東勝 \n 40723124 \xa0 徐敬倫 \n 40723125 \xa0 張詠全 \n 40723152 \xa0 陳俊任 \n 40723155 \xa0 吳明峰 \n \n', 'tags': '', 'url': 'member.html'}, {'title': 'Final Focus', 'text': '1.動靜態網頁維護 \n 2.Reveal簡報 \n 3.pelican網誌 \n 註:要協同編輯網誌，每位組員都要有一個獨立的Leo editor\xa0 \n', 'tags': '', 'url': 'Final Focus.html'}, {'title': 'week practice', 'text': 'week10-11 \n \n 以分組協同方式整理教科書內容: \n \n 2015- Space Modeling with SolidWorks and NX https://link.springer.com/book/10.1007/978-3-319-03862-9 \n 各組員負責將課程重點與零組件繪圖練習, 加上解說與操作過程影片, 放入分組倉儲中. \n 2008- The Engineering Design Revolution The Engineering Design Revolution \xa0(a.k.a. cad_history.pdf) \n 各組員負責編寫 Solidworks, NX, Inventor 與 Creo (Pro/E) 的開發緣起, 套件安裝與設定流程, 以及利用各套件執行零組件繪圖的相關差異與特點分析, 分別放入分組倉儲中. \n \n \n Github 分組倉儲如何 fork, 如何建立正向 pull requests, 如何反向 pull requests, 組長如何處理各組員的 pull requests 內容, 如何處理 content.htm, reveal 簡報以及 pelican 網誌 markdown 中的改版衝突. (含 \xa0 GitExtensions 導入 ) \n \n \n NX12 零組件繪圖與 NXOpen Python 檔案的建立與應用.  ( http://mde.tw/cad2019/content/Task2.html ) \n \n \n 各組員分別執行 V-rep 與 Webots Tutorial, 分別利用 Solvespace 與 NX 建立零組件轉入, 比較兩者差異  ( http://mde.tw/cad2019/content/Task3.html ) \n \n \n 分組執行 \xa0 http://mde.tw/cad2019/content/Project.html \xa0 期末專案 \n \n \n \n week12 \n \xa0 NX 零組件繪圖 \n 請根據 \xa0 http://mde.tw/cad2019/downloads/NX-12-for-Engineering-Design.pdf \xa0 的導引, 透過分組協同完成各章節內容閱讀與操作練習, 並將練習影片加上說明字幕, 以 校名+系名+課程名稱+分組任務名稱+學號作為標題 , 上傳 Youtube 後, 分別嵌入個人與分組網頁中. \n 使用 NX3 者可以參考 \xa0 http://mde.tw/cad2019/downloads/UG-NX3-Tutorial.pdf \n 目的在能使用 NX 建立 \xa0 http://mde.tw/cad2019/content/Task2.html \xa0 完成越野車零組件的設計與繪圖, 並利用 CAE 模組進行零件的應力分析. \n Webots 與 V-rep Tutorial \n 請各組員在第十三週之前完成: \n https://cyberbotics.com/doc/guide/tutorial-1-your-first-simulation-in-webots \n 與 \n http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm \n 並將操作過程製作成帶字幕影片, 上傳 Youtube 後, 分別嵌入個人與分組網站, 且將心得與兩者的比較內容放在個人與分組網誌中. \n \n week13 \n 每週將分別就課程任務執行結果與心得, 在個人與分組 Reveal 中進行各週簡報, 以作為期末自評與互評成績評定之參考. \n', 'tags': '', 'url': 'week practice.html'}, {'title': 'week12網址與心得', 'text': '40523113 \xa0 吳宜賢 \n \n 40623252 \xa0 李展齊 \n 40723101 \xa0 沈易萱 \n 40723103 \xa0 林晏瑩 \n 網址: https://www.youtube.com/watch?v=tgTjdzZdQTk (NX12之操作) \n \n 心得: \n 對於剛接觸兩款軟體的新手而言， NX12 為接受度較高的高階套件， 模擬與加工程序與應力分析和繪製3D草圖為該套件之特色， 並且指令相對於簡潔明瞭，運用在繪製草圖或是物件分析的部分都做得相對周到，儘管模擬加工方面之限制比較多之外，整體操作上較為順手。 \n 另一方面 Webots 主要為3D模擬套件，實際使用物體去模擬移動位置，可變換出不同場景已供參考，在設定操作步驟方面相對繁瑣，而測試機器人與機械傳動件作動為該套件主要特性，也可 指定對象的圖形和物理屬性。 \n 註 : 圖形屬性包括對象的形狀，尺寸，位置和方向，顏色和紋理。 \n 兩者套件比較下，個人偏向使用NX操作，因操作明瞭標示明顯，各指令也會給予相對詳細的解說，是新手也能操作順手的軟體。 \n 40723107 \xa0 王晨祐 \n \n 心得 :\xa0 第一次使用nx12繪圖還有些不習慣，經過電子書的說明跟閱讀後才懂得如何約束草圖上的線，比起solvespace的操作nx12的內容更加複雜也擁有比較多的應用可以使用，例如模擬與加工程序與應力分析這些功能可以使用，比起solvespace 跟 inventor這些繪圖程式，nx12的功能雖然比較繁多相反的需要更多時間去摸索跟熟悉。 \n 40723114 \xa0 杜永瀚 \n https://www.youtube.com/watch?v=LPlDoJRslU0 \n \n 心得: \n 在使用NX12的時候,一開始很不習慣,因為NX12為高階cad軟體,所以花了一些時間摸索,用完NX12發現它的功能很強大也很多,但操作起來也變得相當複雜,之前常用SOLID WORK,發現SOLID WORK用起來是比NX12好上手,但NX12功能較多,也較廣泛. \n 40723119 \xa0 林哲緯 \n 40723122 \xa0 施東勝 \n 40723124 \xa0 徐敬倫 \n 40723125 \xa0 張詠全 \n \n 心得:第一次使用NX12繪製，還不習慣只能做到簡單的特徵，在這本 NX 12 for Engineering Design 原文書中可以學到很多進階的操作，目前我只讀到第2章就能繪製成這樣，在讀下去就不得了! \n 40723152 \xa0 陳俊任 \n 40723155 \xa0 吳明峰 \n', 'tags': '', 'url': 'week12網址與心得.html'}, {'title': 'week13', 'text': '第13週-Solvespace 與 NX12 參數繪圖與 V-rep 結合應用 \n 重點筆記: 講解NX3與NX12之間特性、差異 \n NX3 使用輸出VRML[選VRML2.0，轉入Webots(副檔名.wrl)] 並勾選選項  1.output lights  2.output matenals  3.recursive multi file 註 :  1.imput VRML為Webots打開之檔案類型  2.solvespace無法轉成wrl檔  3.wrl檔為文字檔   NX12 重要檔案  1.NXASSEMBLY(作用為轉檔)=IGES也是轉檔  2.NXBIN  3.UGII 註:  1.Journal=畫圖中並同時儲存   比較差異 \n NX3 =較陽春，但簡便，可執行放在UGII檔裡 \n NX12 =規格、功能性相對齊全，但為了配合Windows 7之後的升級改版，直接將大部分檔案放在NXBIN裡，不過有些重要檔案仍儲存在UGII裡。 \n HOW TO\xa0 將NX12程式語言改成Python \n 改寫位置之操作順序: File>Preferences>User interface>Tools \n 原先Journal language中將Visual Basic選項改為Python選項 \n 目的: 主要方面日後藉由程式去操作NX12 \n', 'tags': '', 'url': 'week13.html'}, {'title': 'week14', 'text': '任務 : \n 同步 啟動跨組自評與互評機制 , 並針對課程內容所要求的任務要項逐一查驗各組員學習成效, 希望在鼓勵組員公開倉儲內容與教學影片互相學習之餘, 也能達到公平計分的目的，同時也強制性規定需作筆記。 \n 在第十四週也逐步介紹NX、Solvespace、Webots的執行與互動 \n Q.如何用SciTe執行Python，與NX、Solvespace、Webots互動 \n A : 程式由外部控制虛擬、實體(大略贅述，詳情敘述只紀錄關鍵字) \n 片刻紀錄 : \n 1 .關鍵字:nx run journal=用python執行，但沒跑出原始碼。 \n 2 .需放Download裡(只是demo)=可直接給路徑<path:path>名稱(yrl.學號)，使學號在路徑連結。 \n 3 .cmsimde@...=為release轉出版本，會改變數字。 \n', 'tags': '', 'url': 'week14.html'}, {'title': 'week15', 'text': '\n \n \n \n', 'tags': '', 'url': 'week15.html'}, {'title': 'week17', 'text': '\n 題目一: (各分組協同製作題) \n 請各組組長將 \xa0 http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm \xa0 與 \xa0 https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment \xa0 等兩份教學內容, 平均分配給各組員, 經由翻譯了解操作過程後, 在各分組網站中, 以 "W17 協同任務" 作為頁面標題, 登錄各組員的分配表, 採用中英文並列的方式呈現兩份教學內容. \n 題目二: (各組員獨立製作題) \n 請參考下列影片中的機構設計, 從 \xa0 https://github.com/mdecourse/cad2019/tree/master/downloads/solvespace/curiosity/ \xa0 擷取草圖設計概念, 利用 Solvespace 或 NX12 將原本車身與主連桿所採用的馬達鎖定設計, 改為機械阻尼(彈簧與極限定位)設計, 完成各零件的尺寸標示工程圖與 Engineering Bill of Material 後轉入 V-rep, 將所有 .slvs (或 .prt) 與 .ttt 檔案放入個人倉儲 downloads 目錄中的 w17/curiosity 目錄後, 將操作過程紀錄於個人網站中的 "W17 個人任務" 頁面中, 並嵌入一個至多 2 分鐘, 帶字幕的影片, 介紹說明操作過程與所完成的結果. \n \n 完成上述兩題後, 請各組員將相關連結(包括題目一的個人貢獻連結與題目二的倉儲連結、網頁連結與影片連結), 放入下列回應中, 並針對所碰到的問題進行說明討論. \n', 'tags': '', 'url': 'week17.html'}, {'title': 'Introduction', 'text': '一 \n 編寫1- solidworks(中階) \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa02-Nx (高階) \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa03-inventor(中階) \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa04-Creo(proe)=oneshape 的開發起源(高階)-已被併購 \n \xa0 \xa0 \xa0 \xa0  \xa0 \xa0註 :中階曲面不強 \n 安裝套件 設定流程 分析各套件零組件差異與特點，放入倉儲。 \n 市占比例: \n solidworks(25%)沒雲端 \n nx(不超過3%) \n inventor(35%) \n creo(pro/e)(35%) \n 二 \n 倉儲如何fork html reveal pelican markdown 中改版衝突 \n 註 :組員需fork 及正向pull request (組長為管理者) \n Week Practice \n', 'tags': '', 'url': 'Introduction.html'}, {'title': '編寫軟體介紹', 'text': 'NX特點 \n •\xa0 \xa0 3D 零件建模使用協力廠商的 CAD 模型。 利用同步建模技術，可直接編輯零件模型，並準備讓零件進入NC編程 。 \n • \xa0 NX 提供建立 NC 操作之前快速進行分析的能力。 \n • \xa0 建模、組立件與製圖-NX 提供了 CAD 功能組合。這些功能已納入 NX CAM 之中，可供用來建立零件、坯件形狀、夾治具或工具機模型以進行模擬。 \n • 模擬技術融合到結構、動作、熱力、流體、多重物理與最佳化解決方案 \n 註 :1-繪圖過程中如有需修改，可直接改寫程式碼，不須改圖。 \n \xa0 \xa0 \xa0 \xa02-產生應力分析，並分析最佳化。 \n CAD \xa0 \n • 製造流程從零件設計資料輸入開始，通常是 3D CAD 模型，在某些情況下也可能是 2D圖面。通常會需要用到 3D CAD 軟體以準備或調整零件設計模型。 \n \n CAD 應用程式也可以用來設計與組合夾治具。NX CAM 套件內含完全整合的 CAD 功能，全部納入同一套 NX 系統之中。 CAM \xa0 \n ======= \n NX特點 \n • \xa0 \xa0 3D 零件建模使用協力廠商的 CAD 模型。 利用同步建模技術，可直接編輯零件模型，並準備讓零件進入NC編程 。 \n • \xa0 NX 提供建立 NC 操作之前快速進行分析的能力。 \n • \xa0 建模、組立件與製圖-NX 提供了 CAD 功能組合。這些功能已納入 NX CAM 之中，可供用來建立零件、坯件形狀、夾治具或工具機模型以進行模擬。 \n • 模擬技術融合到結構、動作、熱力、流體、多重物理與最佳化解決方案 \n 註 :1-繪圖過程中如有需修改，可直接改寫程式碼，不須改圖。 \n \xa0 \xa0 \xa0 \xa02-產生應力分析，並分析最佳化。 \n CAD \xa0 \n • 製造流程從零件設計資料輸入開始，通常是 3D CAD 模型，在某些情況下也可能是 2D圖面。通常會需要用到 3D CAD 軟體以準備或調整零件設計模型。 \n \n CAD 應用程式也可以用來設計與組合夾治具。NX CAM 套件內含完全整合的 CAD 功能，全部納入同一套 NX 系統之中。 CAM \xa0 \n • NX CAM 包含 NC 編程、後處理及工具機模擬。 \n \n • 套件Siemens 為進階工具機控制器技術及驅動設備領域的公認領導廠商。 提供 CAD-CAM-CNC 流程鏈支援，讓您最新的工具機投資價值發揮到極致。 \n \n 電子書: \n \n https://docs.plm.automation.siemens.com/docs/nx/12.0.1/en_US/release_notes.pdf \n \n 1. SMP \n Symmetric Multiprocessing (SMP) is supported in NX mostly via Parasolid, although a small number \n \n 翻譯:\n NX主要通過Parasolid支持對稱多處理（SMP），儘管數量很少 2. 目錄 The new NX runtime directory does not contain all binaries and executables. Only the most frequently used files from the following directories have been moved: •  UGII •  UGMANAGER •  STEP203UG •  STEP214UG •  PVTRANS •  MACH Other files will also be moved over time. However, some applications, such as NX Nastran, will not be moved. \n=======\n 1.SMP \n Symmetric Multiprocessing (SMP) is supported in NX mostly via Parasolid, although a small number \n \n 翻譯:\n NX主要通過Parasolid支持對稱多處理（SMP），儘管數量很少 2.目錄 The new NX runtime directory does not contain all binaries and executables. Only the most frequently used files from the following directories have been moved: •  UGII •  UGMANAGER •  STEP203UG •  STEP214UG •  PVTRANS •  MACH Other files will also be moved over time. However, some applications, such as NX Nastran, will not be moved. \n 翻譯: \n 新的NX運行時目錄不包含所有二進製文件和可執行文件。 僅移動了以下目錄中最常用的文件：\n • UGII\n • UGMANAGER\n • STEP203UG\n • STEP214UG\n • PVTRANS\n • 馬赫\n其他文件也會隨著時間的推移而移動。但是，某些應用程序（例如NX Nastran）將\n不動。 \n \n 3. 版本 Historically, the NX product release has included the refile utility, which was created many years ago This utility was never mandatory when performing NX upgrades. NX product enhancements and improvements that are delivered and available in the current NX release make NX upgrades much faster and easier, so the refile utility is now obsolete.  the refile utility is retired starting in NX 12.0.1. The documentation for the utility has already been removed in NX 12. In place of the refile utility, standalone utilities will be introduced that incorporate non-version-up related options and future NX batch processes. Teamcenter names and values of properties localized \n 3.版本 Historically, the NX product release has included the refile utility, which was created many years ago This utility was never mandatory when performing NX upgrades. NX product enhancements and improvements that are delivered and available in the current NX release make NX upgrades much faster and easier, so the refile utility is now obsolete.  the refile utility is retired starting in NX 12.0.1. The documentation for the utility has already been removed in NX 12. In place of the refile utility, standalone utilities will be introduced that incorporate non-version-up related options and future NX batch processes. Teamcenter names and values of properties localized \n • there is now the capability to have the names and values of properties translated and displayed in multiple languages.  \n • the Part Family template spreadsheet \n \xa0 \n • New Item \n • Save \n • Import, and component properties dialog boxes. \n \n 翻譯: \n 從歷史上看，NX產品版本包含了refile實用程序，該實用程序是多年以前創建的， 執行NX升級時，該實用程序從不是必需的。  當前NX中提供和可用的NX產品增強和改進 發布版本使NX的升級變得更快，更容易，因此refile實用程序現在已過時。 \n從NX 12.0.1開始，重新歸檔實用程序已停用。該實用程序的文檔已經在NX 12中已刪除。\n代替refile實用程序，將引入合併非版本升級的獨立實用程序，其中包含與非版\n本相關選項和將來的NX批處理過程。\n Teamcenter名稱和屬性值已本地化 \n • 現在可以轉換屬性的名稱和值，並 以多種語言顯示。 \n • 零件族模板電子表格 \n • 新選項 \n • 保存 \n • “導入”和“組件屬性”對話框。 4. 尺寸 When you run the ug_convert_part tool to convert an NX 12 part from mm to inch, the settings in the Unit Manager dialog box do not display the converted units. This is as intended. 翻譯: \n 當運行ug_convert_part工具將NX 12零件從毫米轉換為英寸時，“單位管理器”對話框中的設置不會顯示轉換後的單位。 這是預期的。 Solid Work特點 1. 介面 -根據工作需求，自行定義SOLIDWORKS環境 2. 繪圖 - 2D設計會自動與3D模型連動，當修改3D模型時，2D的設計草圖就會自動更新 \n • “導入”和“組件屬性”對話框。 4.尺寸 When you run the ug_convert_part tool to convert an NX 12 part from mm to inch, the settings in the Unit Manager dialog box do not display the converted units. This is as intended. 翻譯: \n 當運行ug_convert_part工具將NX 12零件從毫米轉換為英寸時，“單位管理器”對話框中的設置不會顯示轉換後的單位。 這是預期的。 Solid Work特點 1. 介面 -根據工作需求，自行定義SOLIDWORKS環境 2. 繪圖 - 2D設計會自動與3D模型連動，當修改3D模型時，2D的設計草圖就會自動更新 \n 自動創建設計的材料清單（BOM）和註解，包括尺寸和公差專家工具。 \n 3. 排除故障 - 設計發生衝突，SOLIDWORKS SketchXpert功能，會協助自動進行問題辨識和故障排除 可大幅減少設計誤差導致的重工和時間、成本上的浪費 4. 曲線 之圖稿與元件設計比其他軟件還好用 5. 成本估算 - 擁有自動成本計算工具，能針對設計的零件製造成本做出估算，可以輸入特定的製造成本和數據，如材料、人工、機器運行速度和損耗，以及安裝成本 \n \n \n \n \n \n \n \xa0 \n 附註 ： (1) SOLIDWORKS不支援Windows家用版 (2) 建議使用Microsoft Windows、Office和IE瀏覽器的最新版本 (3) 不支援Microsoft Office 即點即用(Click-To-Run)功能 \n 附註： (1) SOLIDWORKS不支援Windows家用版 (2) 建議使用Microsoft Windows、Office和IE瀏覽器的最新版本 (3) 不支援Microsoft Office 即點即用(Click-To-Run)功能 \n \n', 'tags': '', 'url': '編寫軟體介紹.html'}, {'title': 'Introduction Pull request', 'text': '正反向拉回差別在於資料傳遞的方向。 \n 假設是正向拉回，是 組員(無權限)將資料推送回組別倉儲後給組長(管理員)確認資料後使其合併 。 \n 反之，反向拉回是 管理者將權限給予組員讓他們擁有可merge的權力 ，不過在這邊很常因為組員推送問題產生衝突，並且解決方式較為繁瑣，因此這學期並不推薦使用反向拉回的方式管理組別倉儲。 \n 以下為正向拉回範例: \n step1 \n 先點入自己分組倉儲之pull request，出現畫面為(圖1) \n \n 這時出現merge問題，但仍可以pull request，並按下Create \n pull request之按鍵 \n step2 確認完再按下標題與傳遞內容後再按下 Create  pull request \n step3 出現畫面代表衝突檔案，需由管理員(組長)確認資料並合併之後處理衝突版面並再次推送， 藉此merge完成 \n \n \n', 'tags': '', 'url': 'Introduction Pull request.html'}, {'title': 'NX 12 for Engineering Design', 'text': 'http://mde.tw/cad2019/downloads/NX-12-for-Engineering-Design.pdf \n 前言 \n \n NX是Siemens PLM Software提供的世界上最先進且緊密集成的CAD / CAM / CAE產品開發解決方案之一。 NX涵蓋了整個產品開發範圍，可為各種規模的企業提供巨大的價值。 它簡化了複雜的產品開發，從而加快了將產品推向市場的過程 \n 第1章簡介 \n 現代製造環境可以通過提供的種類越來越多的產品，小批量和更高的質量在提高全球競爭的背景下的模式為特徵。除非行業以更高的質量，更低的成本和更短的交付時間推出新產品，否則它們就無法在全球競爭中生存。國際競爭激烈，技術工人的供應減少。 隨著計算能力的巨大變化和用於設計和生產的軟件工具的廣泛可用性，現在工程師都使用計算機輔助設計（CAD），計算機輔助製造（CAM）和計算機輔助工程（CAE）系統來自動化設計和生產過程。現在這些技術每天都用於各種不同的工程任務。 以下是產品實現過程中如何使用CAD，CAM和CAE技術的簡要說明。 \n CAD / CAM / CAE的定義 \n • 計算機輔助設計– CAD \n \xa0 \xa0 \xa0 CAD技術是涉及使用計算機系統協助創建，修改，分析和優化設計。 \n • 計算機輔助製造– CAM \n \xa0 \xa0 CAM技術涉及到計算機系統規劃管理，並與工廠的生產資源的控制通過計算機接口的製造業務。 \n • 計算機輔助工程– CAE \xa0 \xa0 CAE技術使用計算機系統來分析CAD創建的產品的功能，從而使設計人員可以模擬和研究產品的性能，從而可以優化和優化設計。 \n 這本原文書是針對有興趣學習如何使用NX 12設計機械零件和組件的學生和工程師編寫的。學習使用NX 12對於學習如何使用其他CAD系統（例如PRO-E和CATIA）也將非常有價值。\xa0 \n 第2章 介紹了從開始會話到熟悉NX的NX 12基本知識。通過練習基本功能（如打印，保存和退出）來佈局12。它還給出了簡短的描述坐標系圖層，各種工具箱和其他重要命令在後面的章節中使用。 \n 第3章 介紹了素描的概念。它描述瞭如何創建草圖並給出幾何和尺寸約束。從今天開始，本章非常重要組件的幾何形狀非常複雜，僅憑基本特徵很難建模。 \n 第4章 開始零件的實際設計和建模。它描述了不同的功能例如參考特徵，掃描特徵和原始特徵，以及如何使用這些特徵創建設計。對特徵執行各種特徵操作。 \n 第5章 中學習如何從零件模型創建工程圖。在本章中，我們通過添加視圖，標註零件圖紙尺寸來演示如何創建圖紙，以及修改圖形中的各種屬性，例如文本大小，箭頭大小和公差。 \n 第6章 介紹了裝配建模的概念及其術語。它描述了Top-向下建模和自下而上建模。我們將使用自下而上的模型進行組裝組件變成產品。 \n 第7章 介紹了自由格式建模。曲線和平滑曲面的建模方法將被演示。 \n 第8章 概述了NX 12中提供的Design Simulations的簡要介紹。 \n 第9章 將是在製造中實施設計模型的實時經驗加工環境。本章介紹工具的生成，驗證和模擬創建CNC（計算機數字代碼）以從多軸生產設計零件的路徑甚至先進的CNC機器。每章中使用的示例和練習問題都經過精心設計，以使它們最終得以應用組裝在本章中。由於這項獨特的功能，您應該保存所有的模型在每一章中都有創建。 \n 資料連結 \n http://mde.tw/cad2019/content/NX.html \n \n', 'tags': '', 'url': 'NX 12 for Engineering Design.html'}, {'title': 'Deal with problems', 'text': 'Q: 當倉儲git pull+分組倉儲網址後發現無法正常開啟近端 \n A:將倉儲start鍵放入文字編輯器並且查看，發現有多一個分號（：），將分號刪除並儲存後即可進入近端 \n BEFORE \n \n \n AFTER \n \n \n Reason:因為有人倉儲本身是壞的，因此當其他人gitpull時會讓他人倉儲錯誤，造成倉儲近端損毀。 \n \n \n Q: 為什麼用了git pull 分組倉儲網址完無法正確連結完成並進行改版 \n A:先將倉儲中最新版本反向拉回（左為本身，右為管理者）並且git commit git push上去後再次進入近端即可改為最新版本進行改版推送 \n EX: \n \n Reason:有可能因為尚未推送回分組倉儲使最新版本與自身隨身碟中可攜系統舊版沒有連結成功，因此git pull 分組倉儲網址完進入近端依然還是舊版 \n \n \n Q 為什麼管理員merge完會使倉儲爆掉，產生舊版與新版衝突(如下) \n \n A: \n 在這次解決問題中，由於近端未有衝突問題並且使用正常，進入近端按下轉靜態後再次git push上傳即可恢復網頁 \n RESEASON (原因 ): \n 有可能是因為其中一位倉儲推送上去使用到git pull的緣故使得新舊版產生合併問題，造成有兩個版面的緣由 \n \n \n Q 進入近端卻直接跳下一行並沒有做任何作動 \n EX: \n D:\\87\\cmsimde>python wsgi.py \n D:\\87\\cmsimde> \n A: \n 將啟動程式按鍵(start_mdecourse.bat)拖曳到SciTe裡，並將裡面其中一行程式多餘的開頭程式 %path% 刪除，重新啟動(按下Stop.bat)即可恢復正常。 \n \n 如上圖所示，但前面的%path%以更改完畢，因此範例中的程式是已經改善完畢的。 \n RESEASON(原因 ): \n 因為%path%為進入近端之bug，需查看是否修正完畢。 \n', 'tags': '', 'url': 'Deal with problems.html'}, {'title': 'webots', 'text': '\n 參考資料 http://mde.tw/cad2019/content/Webots.html \n webots:有五種程式可運用，ex:C、C++、Python、Java、MATLAB，為零組件組合軟件。 \n 註解 :建立模型孔需有間隙(SOLVESPACE)，因轉出零件檔案(零件件數有多少，就轉多少次)，再轉入WEBOTS。 \n 目前因WEBOTS還是商用化，因此檔案仍停留在1999年。 \n', 'tags': '', 'url': 'webots.html'}, {'title': 'webots安裝', 'text': '下載位置: Webots_2019b_rev1.7z \n 1.新增啟動器 \n \n 2. 執行路徑設定 \n set path_webots=%Disk%:\\Webots_2019b_rev1\\msys64\\mingw64\\bin;%Disk%:\\Webots_2019b_rev1\\msys64\\usr\\bin \n %path_webots%; \n \n \n 3.設定抓取的檔案 \n start webots.exe%*\n \n \n 4.將檔案丟入啟動器底下 \n \n', 'tags': '', 'url': 'webots安裝.html'}, {'title': 'W17 協同任務', 'text': '\n 翻譯原文書 \n http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm \n https://cyberbotics.com/doc/guide/tutorial-2-modification-of-the-environment \n', 'tags': '', 'url': 'W17 協同任務.html'}, {'title': 'Webots User Guide', 'text': '翻譯: 用戶指南手冊 \n Tutorial 2: Modification of the Environment (30 Minutes) In this tutorial, we will teach you how to create simple objects in the environment. The first step will be to create a ball which will interact with the environment. We will tackle several concepts related to the nodes: what is their meaning, how to create them, how they have to be affiliated, etc. Moreover we will see how to set up physics. \n Several kinds of nodes will be introduced. Their detailed definition can be found in Reference Manual. Having the nodes chart diagram in front of you, will also help understanding the nodes inheritance relationship. \n 翻譯: 教程2：修改環境（30分鐘） 教學如何在環境中創建雛形。第一步將創建一個與環境互動的球。我們將處理與節點有關的幾個概念：如何創建它們、如何關聯它們等等。 此外，還需將了解如何設置物理學。 \n 以下將介紹幾種節點。詳細定義可在參考手冊中找到。擁有節點圖表，也將助於理解節點繼承關係。 \n Index A New Simulation Modifying the Floor The Solid Node Create a Ball Geometries DEF-USE Mechanism Add Walls Solution: World File Efficiency Conclusion \n 翻譯: \n 索引 新建模擬 修改地板 節點 創建球體 幾何形狀 定義使用機制 添加牆 解決方案：世界文件 效率 結論 \n \n A New Simulation First we create a new simulation based on the one created in Tutorial 1. \n Hands-on #1: Make sure the my_first_simulation.wbt world file is open, and that the simulation is paused and is at a virtual time of 0. Using the File / Save World As... menu, save the simulation as obstacles.wbt. \n 翻譯: 新建模擬 首先根據教程1中創建的模擬創建一個新的模擬。 \n 步驟1：確保打開了my_first_simulation.wbt文件，並且模擬已暫停並且處於虛擬時間0。使用“文件/另存世界為...”菜單，保存the simulation為obstacles.wbt。 \n \n Modifying the Floor The default RectangleArena PROTO defines a simple floor pinned on the static environment, i.e. without Physics node, and surrounded by walls. Other pre-built floors are available in the Webots objects library. We will now delete the RectangleArena node and add a simple floor that we will manually surround with walls later in this tutorial. \n Hands-on #2: To remove the RectangleArena, select it either in the 3D view or in the scene tree view with a left click and press the Delete key on your keyboard. Alternatively, you can right click on it in the 3D view and select Delete in the context menu (you can also use the context menu directly in the scene tree view). Select the TexturedBackroundLight node and click on the Add button. In the open dialog box, and choose PROTO nodes (Webots Projects) / objects / floors / Floor (Solid). \n The newly added Floor PROTO has a default size of 10mx10m, but it is possible to adjust its size, its position and texture by changing the corresponding fields. \n Hands-on #3: In the scene tree view select and expand the Floor. Modify the size field and set it to {1, 1} to resize it to 1mx1m. \n 翻譯: 修改地板 默認的RectangleArena PROTO定義一個固定在靜態環境上的Floor，即沒有Physics節點並且被牆壁包圍。 Webots對像庫中提供了其他預建樓層。現在，我們將刪除RectangleArena節點，並添加一個簡單的Floor，在本教程的後面部分將用牆手動將其包圍。 \n 步驟2：要刪除RectangleArena，在3D視圖或場景樹視圖中單擊鼠標左鍵選重物件，然後按下Delete鍵。 或者，可以在3D視圖中右鍵單擊它，然後在上下文菜單中選擇“刪除”（也可以直接在場景樹視圖中使用上下文菜單）。 選擇TexturedBackroundLight節點，然後單擊“添加”按鈕。 在打開的對話框中，然後選擇PROTO節點（Webots項目）/對象/ Floors / Floor（實心）。 \n 增添新的Floor PROTO的尺寸為10mx10m，也可以通過更改相應的字段來調整其大小，位置和紋理。 \n 步驟3：在場景樹視圖中，選擇並展開“Floor”。修改大小字段並將其設置為{1，1}以將其大小調整為1mx1m。 \n \n The Solid Node \n This subsection introduces the most important base node in Webots: the Solid node, from which many other nodes derive. \n A Solid node represents a rigid body, that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies. \n The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies. \n To define a rigid body, you will have to create a Solid node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following figure depicts a rigid body and its sub-nodes. The graphical representation of the Solid node is defined by the Shape nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined. \n The Geometry box (in this figure) stands for any kind of geometrical primitive. In fact, it can be substituted by a Sphere, a Box, a Cylinder, etc. \n 翻譯: \n 節點 這部分介紹了Webots中的基礎節點：Solid節點，許多其他節點都來自Solid節點。 \n 實體節點表示剛體，即可以忽略變形的剛體。 剛體上任意兩個給定點之間的距離在時間上保持恆定，而不管施加在其上的外力如何。 例如，桌子，機械手指骨或輪子是剛體。 軟體和關節物體不是剛體。 例如，繩索，輪胎，海綿或關節式機械臂不是剛性體。 可將一個鉸接的實體分解為幾個剛體。 \n Webots的物理引擎僅設計用於模擬剛體。設計仿真時，重要的一步是將各個實體分解為單獨的剛體。 \n 要定義剛體，必須先創建一個節點。在此節點內，將根據剛體的特性設置不同的子節點。下圖描繪了剛體及其子節點。實體節點的圖形表示由填充其子級列表的Shape節點定義。碰撞範圍在其boundingObject字段中定義。圖形表示和碰撞形狀通常但不一定相同。最後，物理字段定義對像是屬於動態環境還是屬於靜態環境。所有這些子節點都是可選的，但物理場需要定義boundingObject。 \n 幾何框代表任何類型的幾何圖元。 實際上，它可以用球體，盒子，圓柱體等代替。 \n \n Create a Ball \n We will now add a ball to the simulation. That ball will be modeled as a rigid body as shown in this figure. A Sphere node will be used to define the geometry of our ball. \n Hands-on #4: In the scene tree view, select the last node and press the Add button. In the dialog, open the Bases nodes section and select the Solid node. In the scene tree view, expand the Solid node and select its children field. Add a Shape node to it by using the Add button. Select the appearance field of the Shape node and use the Add button to add a PBRAppearance node. \n Add a Sphere node as the geometry field of the newly created Shape node. Expand the PBRAppearance node and change its metalness field to 0 and its roughness field to 1. Add another Sphere node to the boundingObject field of the Solid. Finally add a Physics node to the physics field of the Solid. By modifying the translation field of the Solid node, place the ball in front of the robot (at {0, 0.2, -0.2} for example). Save the simulation. The result is depicted in this figure. tutorial_ball.png Your first rigid body in Webots. When the simulation is started, the ball hits the floor. You can move the ball by applying a force to it (Ctrl + Alt + left-click + drag). The contact points between the ball and the floor can be displayed as cyan lines by enabling the View / Optional Rendering / Show Contact Points menu item. \n 翻譯: 創建球體 將球添加到模擬中。如圖所示，該球將被建模為剛體。球體節點將用於定義球的幾何形狀。 \n 步驟4：在場景樹視圖中，選擇最後一個節點，然後按“添加”按鈕。在對話框中，打開“基礎節點”部分，然後選擇“實體”節點。在場景樹視圖中，展開“實體”節點並選擇其子字段。使用“添加”按鈕向其添加一個Shape節點。選擇“形狀”節點的外觀字段，然後使用“添加”按鈕添加一個PBRAppearance節點。 \n 將球體節點添加為新創建的形狀節點的幾何字段。 展開PBRAppearance節點，並將其金屬性字段更改為0，並將其粗糙度字段更改為1。 將另一個Sphere節點添加到Solid的boundingObject字段。 最後，將一個Physics節點添加到Solid的Physical字段。 通過修改實體節點的平移字段，將球放置在機器人的前面（例如，在{0，0.2，-0.2}處）。 保存模擬。 結果如圖所示。 tutorial_ball.png Webots中的第一個剛體。 當模擬開始時，球擊中地板。可通過向球施加力來移動球（Ctrl + Alt +左鍵單擊+拖動）。 \n 通過啟用“查看/可選渲染/顯示接觸點”菜單項，可以將球和地板之間的接觸點顯示為青色線。 \n Geometries To define the ball, we used the Sphere node in two different contexts: for the graphical representation (children) and to define the physical bounds (boundingObject). All Geometry nodes (such as the Sphere node) can be used in a graphical context. However, only a subset of them can be used in a physical context. The nodes chart diagram indicates which nodes are supported in each context. \n We are now going to reduce the size of the Sphere and increase its graphical quality by increasing the number of triangles used to represent it. \n Hands-on #5: For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for. \n 翻譯: \n 幾何形狀 為了定義球，在兩個不同的上下文中使用了Sphere節點：用於圖形表示（子代）和定義物理邊界（boundingObject）。 使得Geometry節點（例如Sphere節點）都可以在圖形上下文中使用。但它們的子集只能在物理環境中使用。 節點圖表顯示了每個上下文中支持哪些節點。 \n 將通過增加用於表示球體的三角形的數量來減小球體的大小並提高其圖形質量。 \n 步驟5：對於定義球的每個Sphere節點，將其半徑字段設置為0.05，並將其細分字段設置為2。 \n 請參閱《參考手冊》以了解細分字段的含義。 \n 定義使用機制 \n DEF-USE機制允許在一個位置定義節點，並在場景樹的其他位置重用該定義。 這對於避免在世界文件中復制相同節點很有用。 此外，它還允許用戶同時修改多個對象。 它是這樣工作的：首先用定義字串標記節點。 然後，可以使用使用關鍵字將該節點的副本重用於其他地方。 只能編輯定義節點的字段，使用的字段從定義節點繼承，並且不能更改。 該機制取決於世界文件中節點的順序。 應在任何相應的使用節點之前定義節點。 \n \xa0 \n 我們之前用來定義球的兩個定義是多餘的。 現在，我們將使用使用定義機制將這兩個球合併為一次。 \n \n DEF-USE Mechanism \n \xa0 \n The DEF-USE mechanism allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node. \n \xa0The two Sphere definitions that we have used earlier to define the ball, are redundant. We will now merge these two Spheres into only once using the DEF-USE mechanism. \n 動手操作6：在場景樹視圖中選擇第一個球節點（球的子級）。 場景樹視圖的字段編輯器允許您輸入定義字串。 \n \xa0在此字段中輸入球_幾何。 \n 選擇邊界物體字段（包含第二個球節點），並通過右鍵單擊場景樹中的字段並在彈出的上下文菜單中選擇“刪除”條目來將其清空。 \n 然後，選擇邊界物體字段，然後單擊“添加”按鈕，然後在對話框中選擇 使用 / 球_幾何。 \n 結果如圖所示。 \n Hands-on #6 : Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string. \n \xa0 \n Enter BALL_GEOMETRY in this field. \n Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up. \n Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box. \n The result is shown in this figure. \n \n 現在，更改第一個球節點的半徑字段也會修改其邊界物體。 \n \xa0為了方便起見，邊界物體字段還接受形狀節點（而不是直接接受球節點）。 如圖所示，也可以在形狀級別使用相同的使用定義機制。 到目前為止，最大的好處就是也可以直接將此形狀用於圖形目的。 後來，對於某些傳感器，該機制將變得非常有用。 \n Now, changing the radius field of the first Sphere node also modifies its boundingObject. \n \xa0For convenience, the boundingObject field accepts also the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure. For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors. \n 動手練習7：使用定義機制的球節點（而不是直接使用形狀節點）創建具有相同參數的第二個球。 \n Hands-on #7 : Create a second ball with the same parameters but using the Shape node (rather than the Sphere node directly) for the DEF-USE mechanism. \n \xa0 \n 添加牆壁 \n \xa0 \n 為了驗證您的進度，請自己實施四面牆以包圍環境。 必須根據環境靜態定義牆壁。 要了解靜態和動態之間的區別，我們將定義的物體（球）放在地面上方。 如果“物理”節點為NULL，則在仿真過程中它將保持凍結狀態（靜態情況）。 如果物理場包含“物理”節點，則它將受重力作用（動態情況）。 \n \xa0在形狀級別而不是幾何級別，盡可能使用定義機制。 實際上，在固體節點的邊界物體字段中添加中間形狀節點更為方便。 實現牆的最佳幾何原語是框節點。 所有牆壁僅需定義一個形狀。 預期結果如圖所示。 \n \xa0實際操作＃8：添加四面牆，無需物理操作，僅使用“形狀”節點的一個定義。 \n \xa0 \n 添加牆壁 \n \xa0 \n 為了驗證您的進度，請自己實施四面牆以包圍環境。 必須根據環境靜態定義牆壁。 要了解靜態和動態之間的區別，我們將定義的物體（球）放在地面上方。 如果“物理”節點為NULL，則在仿真過程中它將保持凍結狀態（靜態情況）。 如果物理場包含“物理”節點，則它將受重力作用（動態情況）。 \n \xa0 \n 在形狀級別而不是幾何級別，盡可能使用定義機制。 實際上，在固體節點的邊界物體字段中添加中間形狀節點更為方便。 實現牆的最佳幾何原語是框節點。 所有牆壁僅需定義一個形狀。 預期結果如圖所示。 \n \xa0 \n 實際操作＃8：添加四面牆，無需物理操作，僅使用“形狀”節點的一個定義。 \n Add wall \n \n In order to verify your progression, implement by yourself four walls to surround the environment. The walls have to be defined statically to the environment. To understand the difference between static and dynamic, let\'s take a defined object (the ball) above the ground. If the Physics node is NULL, it will remain frozen in the air during the simulation (static case). If the physics field contains a Physics nodes, it will fall under the effect of gravity (dynamic case). \n \xa0 \n Use as much as possible the DEF-USE mechanism at the Shape level rather than at the Geometry level. Indeed it\'s more convenient to add an intermediate Shape node in the boundingObject field of the Solid node. The best Geometry primitive to implement the walls is the Box node. Only one Shape has to be defined for all the walls. The expected result is shown in this figure. \n \xa0 \n Hands-on #8: Add four walls without physics and using only one definition of the Shape node. \n \xa0 Solution: World File \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in Tutorial 1, then go to the "worlds" folder and open with a text editor the right world. This solution as the others is located in the solution directory. \n \n \xa0 \n \xa0效率 \n 剛體的模擬在計算上是昂貴的。 可以通過以下方法來提高仿真速度：最小化邊界對象的數量，最小化邊界對象之間的約束（有關下一個教程的約束的更多信息），並最大化WorldInfo.basicTimeStep字段。 在每個模擬中，必須在模擬速度和真實性之間找到一個折衷。 \n Efficiency \n The simulation of rigid bodies is computationally expensive. The simulation speed can be increased by minimizing the number of bounding objects, minimizing the constraints between them (more information about the constraints in the next tutorials), and maximizing the WorldInfo.basicTimeStep field. On each simulation, a trade-off has to be found between simulation speed and realism. \n 結論 \n 在本教程的最後，您將能夠基於剛體創建簡單的環境。 您可以從場景樹視圖添加節點並修改其字段。 您已經熟悉了“實體”，“物理”，“形狀”，“球體”和“盒子”節點。 您還看到了使用定義機制，該機制可減少場景樹的節點多餘。 \n conclusion \n At the end of this tutorial, you are able to create simple environments based on rigid bodies. You are able to add nodes from the scene tree view and to modify their fields. You have become acquainted with the Solid, Physics, Shape, Sphere and Box nodes. You also saw the DEF-USE mechanism that allows to reduce node redundancy of the scene tree. \n', 'tags': '', 'url': 'Webots User Guide.html'}, {'title': 'Building a clean model tutorial', 'text': 'When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage. \n \xa0 \n We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create pure shapes, or regular shapes. Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application. \n \xa0 \n When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn\'t contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g. minimum distance calculation, or dynamics). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim): \n \n \n \n \n 建立一個模型 \n \n \n \n \n 在構建新模型時，首先，我們先處理它的視覺方面；而動態方面（其簡化，優化模型的不合理之處）、關節及傳感器等將在以後階段進行處理。 \n 現在，我們可以使用[菜單->添加->基本形狀-> ...]在CoppeliaSim中直接創建基本形狀。. 在處理這個的時候, 我們創建形狀有分純形狀或正多邊形。純形狀會優化動力相互作用,也可以使它直接的動起來(即墜落、碰撞，但是可以在以後禁用)。原始形狀將會成為簡單的網格, 但對於我們的應用程序，可能沒有足夠的細節或幾何精度.。在這種情況下，我們的另一種選擇是從外部應用程序導入網格。 \n 當層外部應用程式輸入CAD資料的時候, 最重要的是確認CAD的模型不會太大，即不要包含太多的三角形。這個需求非常的重要因為笨重的模型需要一段時間來顯示，也減緩了以後可能使用的各種計算模塊的速度 (例如最小距離計算或動態).。以下示例通常是不行的 (即使變成稍後看到的那樣，也還是有方法可以簡化CoppeliaSim中的數據): \n Above CAD data is very heavy: it contains many triangles (more than 47\'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20\'000 triangles, but most of the time 5\'000-10\'000 triangles would just do fine as well. Remember: less is better, in almost every aspect. \n \xa0 \n What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n \xa0 \n CoppeliaSim supports currently following CAD data formats: OBJ, STL, DXF, 3DS (Windows only), and Collada. URDF is also supported, but not mentionned here since it is not a pure mesh-based file format. \n \xa0 \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n 以上CAD數據非常繁重: 它包含了非常多的三角形 (超過47000個), 如果我們只在空的場景中使用它的單個實例，那沒關係。但是大多數時候，您將需要模擬同一機器人的多個實例，連接各種類型的夾爪，並可能使這些機器人與其他機器人，設備或環境進行交互。在這種情況下，模擬場景可能會變得太慢。 \n 通常，我們建議對不超過2萬個三角形的機器人進行建模，在大多數情況下，5 000至10 000個三角形也可以。但記住：在幾乎所有方面，少即是好。 \n 是什麼讓模型那麼複雜? 首先，包含孔和小細節的模型將需要更多的三角形面才能正確表示。因此，如果可以，請嘗試從原始模型數據中刪除所有的孔、螺釘以及物體的內部等。 如果您將原始模型數據表示為參數化曲面/對象，則通常在大多數情況下只需選擇並刪除它們即可（例如在Solidworks中）。第二個重要的步驟是以有限的精度導出原始數據：大多數CAD應用程序都允許您指定導出的網格的詳細程度。 \n 當模型含有不同大小的物體時分幾步導出對象也可能很重要; 它的目的是避免太大的對象定義太精確（三角形太多）和太小的對象定義太粗（三角形太少）：只需先導出大對象（通過調整所需的精度設置），然後導出小對象（通過調整精度設置）即可。 \n CoppeliaSim當前支持以下CAD數據格式：OBJ，STL，DXF，3DS（僅Windows）和Collada。還支持URDF，但此處未提及，因為它不是基於純網格的文件格式。現在，就算我們已按照上一節中所述應用了所有可能的簡化，導入後，我們可能仍然留下一些過複雜的網格： \n \n You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n At this stage, we have several functions at our disposal, to simplify the mesh: \n \n Automatic mesh division: allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n Extract the convex hull: allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n Decimate the mesh: allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n Remove the inside of the mesh: allows to simplify the mesh by removing its inside. This function is based on\xa0 vision sensors \xa0and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let\'s suppose the first item in the list didn\'t work for us): \n \n 您會注意到整個機器人是作為單個網格導入的，稍後我們將看到如何對其進行適當劃分。還要注意導入的網格的方向錯誤：最好保持原來的方向， \n 直到構建完整個模型為止，因為如果以後要導入與同一機器人相關的其他項目，則它們將自動具有相對於原始網格的正確位置/方向。在此階段，我們可以使用多種功能來簡化網格： \n \xa0 \n \xa0 \n \xa0 \n \n 自動網格劃分：允許為未通過公共邊鏈接在一起的所有元素生成新形狀，這不總是適用於選定的網格，但是總是值得一試的，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。可以通過 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分割所選形狀 ] 訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（ [ 菜單 -> 編輯 -> 分組 / 合併 -> 合併選定的形狀 ] ）。 \n 提取凸點：通過將其轉換為凸點來簡化網格。可以通過 [ 菜單 -> 編輯 -> 將選擇變形為凸形 ] 來訪問該功能。 \n 抽取網格：減少網格中包含的三角形數量。可以通過 [ 菜單 -> 編輯 -> 縮小所選形狀 ...] 使用該功能。 \n 刪除網格的內部：允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，根據所選設置可能會或多或少地令人滿意。可以通過 [ 菜單 -> 編輯 -> 提取選定形狀的內部 ] 訪問該功能。 \n \n 沒有/可以應用上述功能的預定義順序（列表中的第一項除外，應始終首先嘗試該項），它在很大程度上取決於我們要簡化的網格的幾何形狀。下圖說明了應用於導入的網格的上述功能（假設列表中的第一項對我們沒有作用）： \n Notice how the convex hull doesn\'t help us at this stage. \n 請注意，凸包在現階段如何對我們沒有幫助， \n We decide to use the mesh decimation function first, \n 我們決定首先使用網格抽取功能 \n \xa0 and run the function twice in order to divide the number of triangles by a total of 50.\xa0 \n 並運行兩次函數以將三角形的總數除以 50 完成後，我們提取簡化形狀的內部並將其丟棄 \n \xa0 We end-up with a mesh containing a total of 2\'660 triangles (the original imported mesh contained more than 136\'000 triangles!).\xa0 \n 我們最終得到一個包含總共 2\'660 個三角形的網格（原始導入的網格包含了超過 136\'000 個三角形！）。 \n \xa0 The number of triangles/vertices a shape contains can be seen in the shape geometry dialog. \n 形狀包含的三角形 / 頂點的數量可以在形狀幾何對話框中看到。 \n \xa02\'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it. \n 對於整個機器人模型，2\'660三角形是極少的三角形，因此視覺外觀可能會因此受到影響。 \n \xa0 At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways: \n 在這一階段，我們可以開始將機器人劃分為單獨的鏈接（請記住，我們目前整個機器人只有一個形狀）。 您可以通過兩種不同的方式執行此操作： \n \xa0 Automatic mesh division: \xa0this function, which was already described in previous section \n 自動網格劃分：此功能已在上一節中進行了描述 \n will inspect the shape and generate a new shape for all elements that are not linked together via a common edge.\xa0 \n 將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。 \n \xa0 This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n \xa0這並不總是有效，但總是值得嘗試的。 可以通過[菜單欄->編輯->分組/合併->分割所選形狀]使用該功能。 \n \xa0 Manual mesh division: \xa0via the the triangle edit mode, you can manually select the triangles than logically belong together, then click\xa0 Extract shape .\xa0 \n 手動網格劃分：通過三角形編輯模式，您可以手動選擇邏輯上不屬於三角形的三角形，然後單擊“提取形狀”。 他將會在場景中產生新的形狀。完成該操作後，刪除選定的三角形。 \n \xa0Now, we could further refine/simplify individual shapes ,Sometimes also, a shape might look better if its convex hull is used instead. \n 現在，我們可以進一步細化/簡化單個形狀，有時，如果改用凸殼，形狀可能會看起來更好。 \n \xa0 Othertimes, you will have to use several of above\'s described techniques iteratively, in order to obtain the desired result. Take for instance following mesh: \n 有時，您將不得不反複使用上述幾種技術，為了獲得理想的結果，以以下網格為例： \n \xa0 The problem with above\'s shape is that we cannot simplify it nicely, because of the holes it contains. \n 上面形狀的問題是，由於其中包含孔，我們無法很好地簡化它。 \n \xa0 So we have to go the more complicated way via the\xa0 shape edit mode , where we can extract individual elements that logically belong to the same convex sub-entity. \n \xa0因此，我們必須通過形狀編輯模式進行更複雜的處理，在該模式下，我們可以提取邏輯上屬於相同凸子實體的單個元素。 \n \xa0 This process can take several iterations: we first extract 3 approximate convex elements. \n 此過程可能需要進行多次疊帶代法：我們首先提取3個近似凸元素。 \n \xa0 For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the\xa0visibility layers, in order to see what is covered by other scene items. \n 現在，我們忽略了兩個孔中的三角形。 在形狀編輯模式下編輯形狀時，可以方便地切換可見性圖層，以查看其他場景項所覆蓋的內容。 \n \xa0 We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes] \n 我們最終得到三個形狀的總和，但是其中兩個將需要進一步改進。 現在我們可以擦除作為兩個孔中的三角形。 最後，我們分別提取3種形狀的凸包，然後將其與[菜單欄->編輯->分組/合併->合併所選形狀]合併在一起 \n \xa0 In CoppeliaSim, we can enable/disable edge display for each shape. We can also specify an angle that will be taken into account for the edge display. \n 在CoppeliaSim中，我們可以啟用/禁用每種形狀的邊緣顯示。 我們還可以指定邊緣顯示時要考慮的角度。 \n \xa0 A similar parameter is the\xa0 shading angle , that dictates how facetted the shape will display. Those parameters, and a few others such as the shape\xa0 color , can be adjusted in the\xa0 shape properties . Remember that\xa0 shapes come in various flavours . In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes. \n 相似的參數是陰影角，它指示形狀將在多方面顯示。 這些參數以及其他一些參數（例如形狀顏色）可以在形狀屬性中進行調整。 請記住，形狀有多種型態。 到目前為止，在本教程中，我們僅處理簡單的形狀：簡單的形狀具有一組視覺屬性（即一種顏色，一個陰影角度等）。 如果合併兩個形狀，則結果將是一個簡單的形狀。 您還可以對形狀進行分組，在這種情況下，每個形狀將保留其視覺屬性。 \n \xa0 In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click\xa0 Apply to selection , once for the\xa0 Colors , once for the\xa0 other properties , in the\xa0 shape properties : this transfers all visual attributes to the selected shapes (including the color name if you provided one). We end up with 17 individual shapes \n \xa0 下一步中，我們可以合併邏輯上屬於一起的元素（如果它們屬於同一剛性元素，並且具有相同的視覺屬性）。 然後，我們更改各種元素的視覺屬性。 調整具有不同顏色和視覺屬性的幾種形狀的最簡便方法，如果我們使用特定的字符串來命名顏色，則以後可以輕鬆地以編程方式更改該顏色，即使該形狀是複合形狀的一部分。 然後，我們選擇所有具有相同視覺屬性的形狀，控制選擇已調整的形狀，單擊“應用於選擇”，一次是“顏色”，一次是其他屬性，在形狀屬性中：這將轉移所有 所選形狀的視覺屬性（如果提供的話，還包括顏色名稱）。 我們最終得到17個單獨的形狀： \n \xa0 Now we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with 7 shapes: the base of the robot (or base of the robot\'s hierarchy tree), and 6 mobile links. It is also important to correctly name your objects: you we do this with a double-click on the object name in the\xa0 scene hierarchy . The base should always be the robot or model name, and the other objects should always contain the base object name, like:\xa0 robot \xa0(base),\xa0 robot_link1 ,\xa0 robot_proximitySensor , etc. By defaut, shapes will be assigned to visibility layer 1, but can be changed in the\xa0 object common properties . By default, only\xa0 visibility layers 1-8 are activated for the scene . We now have following (the model\xa0 ResizableFloor_5_25 \xa0was temporarily made invisible in the\xa0 model properties dialog ) \n \xa0現在，我們可以使用[菜單欄->編輯->分組/合併->分組所選形狀]對屬於同一鏈接的形狀進行分組。 我們最終得到7個形狀：機器人的基礎（或機器人的層次結構樹的基礎）和6個移動鏈接。 正確命名對像也很重要：您可以通過雙擊場景層次結構中的對象名稱來做到這一點。 基礎應始終是機械手或模型名稱，其他對象應始終包含基礎對象名稱，例如：robot（基礎），robot_link1，robot_proximitySensor等。通過默認，形狀將分配給可見性層1，但可以 在對象通用屬性中進行更改。 默認情況下，僅激活場景的可見性層1-8。 現在，我們有了以下內容（模型ResizableFloor_5_25模型在模型屬性對話框中暫時不可見） \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape\'s reference frame will always be positioned at the shape\'s geometric center. The frame orientation will be selected so that the shape\'s bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape\'s reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the\xa0 shape geometry dialog . \n 創建或修改形狀時，CoppeliaSim將自動設置其參考框架的位置和方向。 形狀的參考框架將始終位於形狀的幾何中心。 將選擇框架方向，以便形狀的邊界框保持盡可能小。 這並不總是看起來不錯，但是我們隨時可以隨時調整形狀的參考框架的方向。 現在，我們可以使用[菜單欄->編輯->重定向邊界框->使用世界參考框架]重新調整所有已創建形狀的參考框架。 您有更多選項可以在形狀幾何對話框中重新定向參考框架。 \n building the joints \n Now we will take care of the joints/motors. Most of the time, we know the exact position and orientation of each of the joints. In that case, we simply add the joints with [Menu bar --> Add --> Joints --> ...], then we can change their position and orientation with the\xa0 position dialog \xa0and\xa0 orientation dialog . In other situations, we only have the Denavit-Hartenberg (i.e. D-H) parameters. In that case, we can build our joints via the tool model located in\xa0 Models/tools/Denavit-Hartenberg joint creator.ttm , in the model browser. Othertimes, we have no information about the joint locations and orientations. Then, we need to extract them from the imported mesh. Let\'s suppose this is our case. Instead of working on the modified, more approximate mesh, we open a new scene, and import the original CAD data again. Most of the time, we can extract meshes or primitive shapes from the original mesh. The first step is to subdivide the original mesh. If that does not work, we do it via the\xa0 triangle edit mode . Let\'s suppose that we could divide the original mesh. We now have smaller objects that we can inspect. We are looking for revolute shapes, that could be used as reference to create joints at their locations, with the same orientation. First, remove all objects that are not needed. It is sometimes also useful to work across several opened scenes, for easier visualization/manipulation. In our case, we focus first on the base of the robot: it contains a cylinder that has the correct position for the first joint. In the triangle edit mode, we have: \n 建立關節 \n 現在我們要來關注關節以及發動機，大多時候，我們知道各個關節間準確的位置和方向。因此，我們簡單的用 [Menu bar --> Add --> Joints --> ...] 加入關節，然後我們可以利用 position dialog 和 \xa0 orientation dialog . 改變他們的位置和方向。在其他情況下，我們只有 Denavit-Hartenberg 參數。在這種情況下，在模型瀏覽器中，我們可以建立關節通過位於 Models/tools/Denavit-Hartenberg joint creator.ttm 中的工具模型。有時我們沒有關於關節方向和位置的資訊。因此，我們需要從導入的 mesh 中叫出他們。假設這是我們的情形，不用在更改和更多近似的 mesh 上做改變，我們打開一個新介面，然後再次導入原始的 CAD 數據。大多時候，我們可以從原始 mesh 中提取 mesh 或原始形狀。第一步是細分原始 mesh ，如果沒有用，我們將用 triangle edit 模式進行。假設我們可以劃分原始 mesh ，現在，我們現在可以檢查更小的物件。我們正在尋找可以用來建立關節在哪個位置的參考，有著一樣取向的旋轉形狀。首先，刪除所有不需要的物件。有時，在好幾個不同的介面中工作也很有用，可以更簡單的視覺化。在我們的案例中，我們首先關注機器人的基底，包含了一個給第一個關節正確位置的圓柱體。在 triangle edit 模式中，我們有 : \n We change the camera view via the\xa0 page selector \xa0 toolbar button , in order to look at the object from the side. The\xa0 fit-to-view toolbar button \xa0can come in handy to correctly frame the object in edition. Then we switch to the\xa0 vertex edit mode \xa0and select all vertices that belong to the upper disc. Remember that by switching some\xa0 layers \xa0on/off, we can hide other objects in the scene. Then we switch back to the triangle edit mode: \n 我們利用頁面中的選擇工具按鈕改變相機的視角，以便從側邊看物件。適合查看的工具欄按鈕可以派上用場，以可以建構在版本中的物件。然後，我們切換到 vertex edit 模式，選擇所有在上碟裡的所有端點。記住，打開或關閉圖層時，我們會隱藏到圖層中的物件。 \n 然後，我們切換回 triangle edit 模式 : \n Now we click\xa0 Extract cylinder \xa0( Extract shape \xa0would also work in that case), this just created a cylinder shape in the scene, based on the selected triangles. We leave the edit mode and discard the changes. Now we add a revolute joint with [Menu bar --> Add --> Joint --> Revolute], keep it selected, then control-select the extracted cylinder shape. In the\xa0 position dialog , on the\xa0 position \xa0tab, we click\xa0 Apply to selection : this basically copies the x/y/z position of the cylinder to the joint. Both positions are now identical. In the\xa0 orientation dialog , on the\xa0 orientation \xa0tab, we also click\xa0 Apply to selection : the orientation of our selected objects is now also the same. Sometimes, we will need to additionally rotate the joint about 90/180 degrees around its own reference frame in order to obtain the correct orientation or rotation direction. We could do that on the\xa0 rotation \xa0tab of that dialog if needed (in that case, do not forget to click the\xa0 Own frame \xa0button). In a similar way we could also shift the joint along its axis, or even do more complex operations. This is what we have: \n 現在，我們點擊提取圓柱體 ( 提取形狀也會開始運作 ) ，這只是根據選取的三角形，在介面中創造一個圓柱體。離開編輯模式並放棄更改。現在我們利用 [Menu bar --> Add --> Joint --> Revolute] 新增一個旋轉關節，讓他保持選定，然後選取提取的圓柱體。在 ” 位置 ” 選項中，點擊 ” 應用到選擇 ”: 這基本上會將圓柱體上的 x/y/z 位置複製到關節上。兩個位置現在都相同了。在方向介面中，我們也點擊 ” 運用到選擇 ”: 我們選擇的物件的方向現在也相同了。有時，我們需要選轉關節 90/180 度，以獲得正確的方向或旋轉方向。如果需要的話，我們也可以在旋轉鍵上執行此操作 ( 這種情況下，別忘記點擊 own frame 鍵 ) 。同樣，我們也可以沿著關節的軸移動關節，甚至進行更複雜的操作，這是我們有的 : \n Now we copy the joint back into our original scene, and save it (do not forget to save your work on a regular basis! The undo/redo function is useful, but doesn\'t protect you against other mishaps). We repeat above procedure for all the joints in our robot, then rename them. We also make all joints a little bit longer in the\xa0 joint properties , in order to see them all. By defaut, joints will be assigned to visibility layer 2, but can be changed in the\xa0 object common properties . We assign now all joints to visibility layer 10, then temporarily\xa0 enable visibility layer 10 for the scene \xa0to also visualize those joints (by default, only visibility layers 1-8 are activated for the scene). This is what we have (the model\xa0 ResizableFloor_5_25 \xa0was temporarily made invisible in the\xa0 model properties dialog ): \n 現在，我們將關節複製回我們原始的介面中，並儲存 ( 不要忘記定期保存你的工作進度 ! 返回功能很有用，但不能保護你免於其他事故的影響 ) 。對機器人中所有關節重複以上的動作，然後重新命名他們。我們也將所有關節的關節屬性變長一點，以便查看所有的關節，默認中，關節將會被分配在可見圖層 2 ，但是可以在公共屬性中進行更改。現在，我們將所有關節改道圖層 10 ，然後只將圖層 10 可見性打開 ( 默認情況下，只會看見圖層 1-8) 。這就是我們所擁有的， ( 模型 ResizableFloor_5_25 \xa0 在模型屬性中暫時不可見 ): \n At this point, we could start to build the model hierarchy and finish the model definition. But if we want opur robot to be\xa0 dynamically enabled , then there is an additional intermediate step: \n 至此，我們可以開始建立模型層次並完成模型定義。但是，如果我們希望啟用 opur 機器人，則還有另一個中間步驟 : \n Building the dynamic shapes \n If we want our robot to be\xa0 dynamically enabled , i.e. react to collisions, fall, etc., then we need to create/configure the shapes appropriately: a shape can be: \n \xa0 \n 建立動態形狀 \n 如果我們希望我們的機器人能夠 動態啟 用 ，即對碰撞，跌落等做出反應，那麼我們需要適當地創建 / 配置形狀：形狀可以是： \n \xa0 \n \n dynamic or static: a dynamic (or non-static) shape will fall and be influences by external forces/torques. A static (or non-dynamic) shape on the other hand, will stay in place, or follow the movement of its parent in the scene hierarchy. \n respondable or non-respondable : a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes. \n \n \xa0 \n 動態或靜態 ：動態（或非靜態）形狀會掉落並受到外力 / 扭矩的影響。另一方面，靜態（或非動態）形狀將保持不變，或跟隨其父級在場景層次中的移動。 \n 可響應或不可響應 ：可響應形狀會引起與其他可響應形狀的碰撞反應。如果它們是動態的，它們（和 / 或它們的對撞機）的運動將受到影響。另一方面，不負責任的形狀如果與其他形狀發生碰撞，則不會計算碰撞響應。 \n 以上說明了兩點 如 下 。負責任的形狀應盡可能簡單，以實現快速穩定的仿真。物理引擎將能夠以不同的速度和穩定性模擬以下 5 種類型的形狀： \n \xa0 \n Pure shapes : \xa0a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --> Add --> Primitive shape]. \n \xa0 \n 純形狀 ：純形狀將穩定並由物理引擎非常有效地處理。缺點是純形狀的幾何形狀受到限制：主要是長方體，圓柱體和球體。如果可能的話，將其用於與其他物品接觸時間較長的物品（例如，人形機器人的腳，串行機械手的底座，抓手的手指等）。可以使用 [ 菜單欄 -> 添加 -> 基本形狀 ] 創建純形狀。 \n \xa0 \n Pure compound shapes : \xa0a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n \xa0 \n 純複合形狀 ：純複合形狀是幾個純形狀的組合。它的性能幾乎與純形狀一樣，並具有相似的特性。可以通過對幾個純形狀進行分組來生成純複合形狀 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分組所選形狀 ] 。 \n Convex shapes : a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --> Add --> Convex hull of selection] or with [Menu bar --> Edit --> Morph selection into convex shapes]. \n \xa0 \n 凸形狀 ：當由物理引擎處理時，凸形狀的穩定性會降低一些，而計算時間也會增加。與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。可以使用 [ 菜單欄 -> 添加 -> 選擇的凸包 ] 或 [ 菜單欄 -> 編輯 -> 將選擇變形為凸形 ] 生成凸形。 \n \xa0 \n Compound convex shapes, or convex decomposed shapes : a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes], with [Menu bar --> Add --> Convex decomposition of selection...], or with [Menu bar --> Edit --> Morph selection into its convex decomposition...]. \n \xa0 \n 複合凸形狀或凸分解形狀 ：凸分解形狀是幾個凸形狀的組合。它的性能幾乎與凸形相同，並具有相似的特性。可以通過將多個凸形分組 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分組選定的形狀 ] ，並使用 [ 菜單欄 -> 添加 -> 選擇的凸分解 ...] 來生成凸分解形狀。 \xa0 ] ，或使用 [ 菜單欄 -> 編輯 -> 將選擇變形到其凸分解 ...] 。 \n \xa0 \n Random shapes : a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible. \n \xa0 \n 隨機形狀 ：隨機形狀是既非凸形也不是純淨的形狀。它通常具有較差的性能（計算速度和穩定性）。盡量避免使用隨機形狀。 \n \xa0 \n So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read\xa0 this page . In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes. \n \xa0 \n 因此，優先順序為：純形狀，純複合形狀，凸形，複合凸形，最後是隨機形狀。確保還閱讀此頁面。對於要構建的機器人，我們將其基座設為純圓柱體，將其他鏈接設為凸形或凸形分解形狀。 \n \xa0 \n We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in\xa0 the first part of the tutorial \xa0a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for\xa0 minimum distance calculations ,\xa0 proximity sensor detections , etc. \n \xa0 \n 我們也可以將動態啟用的形狀用作機器人的可見部分，但是看起來可能不夠好。因此，相反，我們將為在本教程第一部分中創建的每個可見形狀構建一個動態啟用的副本，該副本將保持隱藏狀態：隱藏部分將代表動態模型，並由物理引擎專用，而可見部分將用於可視化，還用於最小距離計算，接近傳感器檢測等。 \n \xa0 \n We select object\xa0 robot , copy-and-paste it into a new scene (in order to keep the original model intact) and start the\xa0 triangle edit mode . If object\xa0 robot \xa0was a compound shape, we would first have had to ungroup it ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]) then merge the individual shapes ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder: \n \xa0 \n 我們選擇對像機器人，將其複制並粘貼到新場景中（以保持原始模型不變），然後啟動 三角形編輯模式 。如果對像機器人是複合形狀，我們首先必須將其取消組合（ [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 取消組合所選形狀 ] ），然後合併各個形狀（ [ 菜單欄 -> 在啟動三角形編輯模式之前，請編輯 -> 分組 / 合併 -> 合併選定的形狀 ] ）。現在，我們選擇代表電源線的幾個三角形，並將其刪除。然後，選擇該形狀中的所有三角形，然後單擊“提取圓柱體”。現在我們可以離開編輯模式，我們的基礎對象表示為純圓柱體： \n \xa0\xa0 \n [Pure cylinder generation procedure, in the triangle edit mode] \n [ 純圓柱體生成過程，在三角形編輯模式下 ] \n \xa0 \n We rename the new shape (with a double-click on its name in the\xa0 scene hierarchy ) as\xa0 robot_dyn , assign it to visibility layer 9, then copy it to the original scene. The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object\xa0 robot_link1 ) and generate a convex shape from it with [Menu bar --> Add --> Convex hull of selection]. We rename it to\xa0 robot_link_dyn1 \xa0and assign it to visibility layer 9. When extracting the convex hull doesn\'t retain enough details of the original shape, then you could still manually extract several convex hulls from its composing elements, then group all the convex hulls with [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. If that appears to be problematic or time consuming, then you can automatically extract a convex decomposed shape with [Menu bar --> Add --> Convex decomposition of selection...]: \n \xa0 \n 我們將新形狀重命名（在場景層次中雙擊其名稱）為 robot_dyn ，將其分配給可見性層 9 ，然後將其複製到原始場景。 其餘鏈接將建模為凸形或複合凸形。 現在，我們選擇第一個移動鏈接（即對象 robot_link1 ），並使用 [ 菜單欄 -> 添加 -> 選擇的凸包 ] 從中生成凸形。 我們將其重命名為 robot_link_dyn1 並將其分配給可見性層 9 。當提取凸包並沒有保留足夠的原始形狀細節時，您仍然可以手動從其組成元素中提取多個凸包，然後將所有凸包與 \xa0 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 對選定形狀進行分組 ] 。 如果這似乎有問題或很耗時，則可以使用 [ 菜單欄 -> 添加 -> 選擇的凸分解 ...] 自動提取凸分解的形狀： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n [Original shape, and convex shape pendant] \n [ 原始形狀和凸形吊墜 ] \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n [Original shape, and convex decomposed shape pendant] \n [ 原始形狀和凸形分解形狀吊墜 ] \n We now repeat the same procedure for all remaining robot links. Once that is done, we attach each visible shape to its corresponding invisible dynamic pendant. We do this by selecting first the visible shape, then via control-click selecting its dynamic pendant then [Menu bar --> Edit --> Make last selected object parent]. The same result can be achieved by dragging the visible shape onto its dynamic pendant in the\xa0 scene hierarchy : \n \n 現在，我們對所有剩餘的機器人鏈接重複相同的過程。 完成後，我們將每個可見的形狀附加到其相應的不可見的動態吊墜上。 為此，我們先選擇可見的形狀，然後按住 Control 鍵並單擊以選擇其動態吊墜，然後選擇 [ 菜單欄 -> 編輯 -> 將最後選擇的對象設為父對象 ] 。 通過將可見形狀拖動到場景層次中的動態吊墜上，可以實現相同的結果： \n \n \xa0 \n [Visible shapes attached to their dynamic pendants] \n [ 動態吊墜附有可見的形狀 ] \n We still need to take care of a few things: first, since we want the dynamic shapes only visible to the physics engine, but not to the other calculation modules, we uncheck all\xa0 object special properties \xa0for the dynamic shapes, in the\xa0 object common properties . \n \xa0 \n 我們仍然需要注意一些事項：首先，由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見，因此在對象通用屬性中取消選中動態形狀的所有對象特殊屬性。 。 \n Then, we still have to configure the dynamic shapes as\xa0 dynamic \xa0and\xa0 respondable . We do this in the\xa0 shape dynamics properties . Select first the base dynamic shape(i.e.\xa0 robot_dyn ), then check the\xa0 Body is respondable \xa0item. Enable the first 4\xa0 Local respondable mask \xa0flags, and disable the last 4\xa0 Local respondable mask \xa0flags: it is important for consecutive respondable links not to collide with each other. For the first mobile dynamic link in our robot (i.e.\xa0 robot_link_dyn1 ), we also enable the\xa0 Body is respondable \xa0item, but this time we disable the first 4\xa0 Local respondable mask \xa0flags, and enable the last 4\xa0 Local respondable mask \xa0flags. We repeat the above procedure with all other dynamic links, while always alternating the\xa0 Local respondable mask \xa0flags: once the model will be defined, consecutive dynamic shapes of the robot will not generate any collision response when interacting with each other. Try to always end up with a construction where the dynamic base of the robot, and the dynamic last link of the robot have only the first 4\xa0 Local respondable mask \xa0flags enabled, so that we can attach the robot to a mobile platform, or attach a gripper to the last dynamic link of the robot without dynamic collision interferences. \n \xa0 \n 然後，我們仍然必須將動態形狀配置為 動態 且 可響應 的。我們在形狀動力學屬性中執行此操作。首先選擇基本動態形狀（即 robot_dyn ），然後檢查“ 主體是可響應的 ”項。啟用前四個“ 本地可響應掩碼 ”標誌，並禁用後四個“ 本地可響應掩碼 ”標誌：對於連續的可響應鏈接不要彼此衝突非常重要。對於我們機器人中的第一個移動動態鏈接（即 robot_link_dyn1 ），我們還啟用了“ 身體可響應 ”項，但是這次我們禁用了前 4 個“ 本地可響應掩碼 ”標誌，並啟用了後 4 個“ 本地可響應掩碼 ”標誌。我們對所有其他動態鏈接重複上述過程，同時始終交替使用“ 本地可響應掩碼 ”標誌：一旦定義了模型，則連續的機器人動態形狀在彼此交互時不會產生任何碰撞響應。嘗試始終以這樣一種構造結束：機器人的動態基礎和機器人的動態最後一個鏈接僅啟用了前 4 個“本地可響應掩碼”標誌，以便我們可以將機器人附加到移動平台，或附加一個抓取器連接到機器人的最後一個動態鏈接，而沒有動態碰撞干擾。 \n \xa0 \n Finally, we still need to tag our dynamic shapes as\xa0 Body is dynamic . We do this also in the\xa0 shape dynamics properties . We can then enter the mass and inertia tensor properties manually, or have those values automatically computed (recommended) by clicking\xa0 Compute mass & inertia properties for selected convex shapes . Remember also\xa0 this \xa0and\xa0 that \xa0dynamic design considerations. This dynamic base of the robot is a special case: most of the time we want the base of the robot (i.e.\xa0 robot_dyn ) to be non-dynamic (i.e. static), otherwise, if used alone, the robot might fall during movement. But as soon as we attach the base of the robot to a mobile platform, we want the base to become dynamic (i.e. non-static). We do this by enabling the\xa0 Set to dynamic if gets parent \xa0item, then disabling the \xa0Body is dynamic item . Now run the simulation: all dynamic shapes, except for the base of the robot, should fall. That attached visual shapes will follow their dynamic pendants. \n \xa0 \n 最後，我們仍然需要將動態形狀標記為“ 身體是動態的 ”。我們也在 形狀動力學屬性 中執行此操作。然後，我們可以手動輸入質量和慣性張量屬性，或者通過單擊“ 計算選定凸形的質量和慣性屬性 ”來自動計算（推薦）那些值。還請記住這一點以及該動態設計注意事項。機器人的這種動態基座是一種特殊情況：大多數時候，我們希望機器人的基座（即 robot_dyn ）是非動態的（即靜態），否則，如果單獨使用，則機器人可能會在運動過程中掉落。但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。我們通過啟用“ 如果獲取父項時設置為動態 ”項，然後禁用“ 主體為動態 ”項來做到這一點。現在運行仿真：除了機器人的基座之外，所有動態形狀都應下降。附加的視覺形狀將跟隨其動態吊墜。 \n Model definition \n Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link ( robot_link_dyn6 ) to its corresponding joint ( robot_joint6 ) by selecting\xa0 robot_link_dyn6 , then control-selecting\xa0 robot_joint6 , then [Menu bar --> Edit --> Make last selected object parent]. We could also have done this step by simply dragging object\xa0 robot_link_dyn6 \xa0onto\xa0 robot_link6 \xa0in the \xa0 scene hierarchy . \xa0 We go on by now attaching\xa0 robot_joint6 \xa0to\xa0 robot_link_dyn5 , and so on, until arrived at the base of the robot. We now have following scene hierarchy: \n 型號定義 \n 現在我們準備定義模型了。 我們從建立模型層次結構開始：通過選擇 robot_link_dyn6 ，然後控制選擇 robot_joint6 ，然後選擇 [ 菜單欄 -> 編輯 -> 創建最後一個選定的對象，將最後一個動態機器人鏈接（ robot_link_dyn6 ）附加到其相應的關節（ robot_joint6 ）。對應的點 ] 。 我們還可以通過簡單地將對象 robot_link_dyn6 拖到 場景層次 結構中的 robot_link6 上來完成此步驟。 現在，我們將 robot_joint6 附加到 robot_link_dyn5 上，依此類推，直到到達機器人的底部。 現在，我們具有以下場景層次結構： \n \n [Robot model hierarchy] \n [機器人模型層次結構] \n \n It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. So we rename robot to robot_visibleBase, and robot_dyn to robot. Now we select the base of the hierarchy tree (i.e. object robot) and in the \xa0 object common properties \xa0 we enable \xa0 Object is model base . We also enable \xa0 Object/model can transfer or accept DNA . A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the \xa0 Don\'t show as inside model selection \xa0 item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation: \n \xa0為模型庫起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。因此，我們將 robot 重命名為 robot_visibleBase ，並將 robot_dyn 重命名為 robot 。現在我們選擇層次結構樹的基礎（即對像機械手），並在 對象公共屬性 中啟用" 對像是模型基礎 \'\' 。我們還使 對象 / 模型可以轉移或接受 DNA 。出現了一個模型包圍盒，包圍了整個機器人。但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。現在，通過對所有關節啟用 “不顯示為內部模型” 選擇項，將關節從模型邊界框中排除。我們可以對模型中的所有不可見項執行相同的過程。這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況： \n \n [Robot model bounding box] \n [機器人模型邊界框 ] \n \n We now protect our model from accidental modification. We select all visible objects in the robot, then enable \xa0 Select base of model instead : if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). Then we select the model and \xa0 modify its position/orientation \xa0 appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0. \n \xa0現在，我們保護模型免受意外修改。我們選擇機器人中的所有可見對象，然後啟用 “選擇模型的基礎” ：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。這使我們可以像對待單個對像一樣操作模型。我們仍然可以通過按住 Shift 鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。現在，我們將機器人置於正確的默認位置 / 方向。首先，我們將當前場景保存為參考（例如，如果稍後需要在當前機器人上導入方向相同的 CAD 數據）。然後，我們選擇模型並適當 修改其位置/方向 。將模型（即其基礎對象）定位在 X = 0 和 Y = 0 處被認為是一種好習慣。 \n \n [Robot model in default configuration] \n [默認配置下的機器人型號 ] \n We now run the simulation: the robot will collapse, since the joints are not controlled by default. \xa0 When we added the joints in the previous stage , we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click Motor \xa0 enabled \xa0 and adjust the \xa0 maximum torque . We then click \xa0 Control loop enabled \xa0 and select \xa0 Position control (PID) . We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate \xa0 toolbar button , or in the \xa0 general dynamics properties . \n \xa0現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。 在上一階段添加關節時 ，我們以力 / 扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的 PID 控制器。在關節動態屬性中，單擊“ 啟用 電機”並調整 最大扭矩 。然後，單擊 啟用控制環 ，然後選擇 位置控制（ PID ） 。現在，我們再次運行仿真：機器人應保持其位置。嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過相應的 工具欄按鈕 或在 常規動力學屬性 中執行此操作。 \n \xa0During simulation, we now verify the scene dynamic content via the \xa0 Dynamic content visualization & verification toolbar button . Now, only items that are taken into account by the physics engine will be display, and the display is \xa0 color-coded . It is \xa0 very important \xa0 to always do this, and specially when your dynamic model doesn\'t behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name. \n \xa0 在仿真過程中，我們現在通過 “動態內容可視化和驗證”工具欄按鈕 來驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該顯示使用 顏色編碼 。始終執行此操作 非常重要 ，尤其是在動態模型無法按預期運行時，為了快速調試模型，尤其如此。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。 \n \n [Dynamic content visualization & verification] \n [動態內容可視化和驗證 ] \n Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways: \n \xa0 by grouping them: \xa0 select the shapes, then [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n \xa0 by attaching them via a force/torque sensor: \xa0 a force torque sensor can also act as a rigid link between two separate dynamically enabled shapes. \n \xa0In our case, only option 2 is of interest. We create \xa0 a force/torque sensor \xa0 with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object robot_link_dyn6. We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to robot_attachment: \n \xa0最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加： \n 通過對它們進行分組： 選擇形狀，然後選擇 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 對選定形狀進行分組 ] 。 \n \xa0 通過力 / 扭矩傳感器進行連接： 力扭矩傳感器還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。 \n \xa0在我們的情況下，只有選項 2 是有意義的。我們使用 [ 菜單欄 -> 添加 -> 力傳感器 ] 創建一個 力/扭矩傳感器 ，然後將其移動到機器人的尖端，然後將其附加到對象 robot_link_dyn6 。我們會適當地更改其尺寸和外觀（紅色力 / 扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為 robot_attachment ： \n \n [Attachment force/torque sensor] \n [附著力 / 扭矩傳感器 ] \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the \xa0 Assembling/disassembling toolbar button . The gripper goes into place: \n \xa0現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住 Control 鍵單擊並單擊附著力傳感器，然後單擊 “ 裝配/拆卸”工具欄按鈕 。夾持器到位： \n \n [Attached gripper] \n [附帶的爪子 ] \n The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click \xa0 Assembling \xa0 in the \xa0 object common properties . Set an empty string for \xa0 \'Parent\' \xa0 match values, then click \xa0 Set matrix . This will memorize the current base object\'s local transformation matrix, and use it to position/orient itself relative to the mobile robot\'s attachment point. To verify that we did things right, we drag the model Models/robots/mobile/KUKA Omnirob.ttm into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the \xa0 Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: \n \xa0抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。 現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。 我們選擇機器人模型，然後在 對象公共屬性 中單擊 “組裝” 。 為“ 父項”匹配值 設置一個空字符串，然後單擊“設置矩陣”。 這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位 / 定向。 為了驗證我們做的正確，我們將模型 Models / robots / mobile / KUKA Omnirob.ttm 拖到場景中。 然後，我們選擇機器人模型，然後在移動平台上按住 Control 鍵並單擊其中一個附接點，然後單擊 “組裝/拆卸”工具欄按鈕 。 我們的機器人應該正確地將自己放置在移動機器人的頂部： \n \n [Attached robot] \n [附帶的機器人 ] \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach \xa0 embedded scripts \xa0 to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand how object handles are accessed from embedded scripts. We can also control/access/interface our model from a \xa0 plugin , from a \xa0 remote API \xa0 client, from a \xa0 ROS \xa0 node, from a \xa0 BlueZero \xa0 node, or from an \xa0 add-on . \n \xa0現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將 嵌入式腳本 附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，請確保了解如 何從嵌入式腳本訪問對象句柄 。我們還可以通過 插件 ， 遠程API 客戶端， ROS 節點， BlueZero 節點或 附加組件 來控制 / 訪問 / 接口模型。 \n \xa0Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the model folder, then the model will be available in the \xa0 model brower . \n 現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用 [ 菜單欄 -> 文件 -> 將模型另存為 ...] 。如果我們將其保存在模型文件夾中，則模型將在 模型瀏覽器 中可用。 \n', 'tags': '', 'url': 'Building a clean model tutorial.html'}]};